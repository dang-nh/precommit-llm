#!/usr/bin/env python3
"""
Command-line interface for LLM pre-commit hooks.
"""
import os
import sys
import argparse
from typing import List, Optional

from llm_precommit.utils.config import load_config, create_default_config_file
from llm_precommit.hooks.llm_code_review import main as run_code_review


def install_hook(args) -> int:
    """
    Install the pre-commit hook into the git repository.
    
    Args:
        args: Command line arguments.
        
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    try:
        # Get the git hooks directory
        hooks_dir = os.path.join(os.getcwd(), ".git", "hooks")
        if not os.path.isdir(hooks_dir):
            print(f"Error: Git hooks directory not found at {hooks_dir}")
            print("Are you in a git repository?")
            return 1
        
        # Create the pre-commit hook file
        hook_path = os.path.join(hooks_dir, "pre-commit")
        
        # Get the path to the llm_code_review.py script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        hook_script_path = os.path.join(script_dir, "hooks", "llm_code_review.py")
        
        # Write the hook file
        with open(hook_path, 'w', encoding='utf-8') as f:
            f.write(f"""#!/bin/sh
# LLM pre-commit hook for code review
# Auto-generated by llm-precommit

{sys.executable} {hook_script_path} "$@"
"""
            )
        
        # Make the hook executable
        os.chmod(hook_path, 0o755)
        
        print(f"Pre-commit hook installed at {hook_path}")
        
        # Create a default config file if it doesn't exist
        config_path = os.path.join(os.getcwd(), ".llm-precommit.yml")
        if not os.path.isfile(config_path):
            create_default_config_file(config_path)
        
        return 0
    
    except Exception as e:
        print(f"Error installing pre-commit hook: {e}")
        return 1


def uninstall_hook(args) -> int:
    """
    Uninstall the pre-commit hook from the git repository.
    
    Args:
        args: Command line arguments.
        
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    try:
        # Get the git hooks directory
        hook_path = os.path.join(os.getcwd(), ".git", "hooks", "pre-commit")
        
        # Check if the hook exists
        if not os.path.isfile(hook_path):
            print("No pre-commit hook found.")
            return 0
        
        # Check if the hook is our hook
        with open(hook_path, 'r', encoding='utf-8') as f:
            content = f.read()
            if "LLM pre-commit hook for code review" not in content:
                print("The existing pre-commit hook was not created by llm-precommit.")
                print(f"Please remove {hook_path} manually if you want to uninstall it.")
                return 1
        
        # Remove the hook
        os.remove(hook_path)
        print(f"Pre-commit hook removed from {hook_path}")
        
        return 0
    
    except Exception as e:
        print(f"Error uninstalling pre-commit hook: {e}")
        return 1


def create_config(args) -> int:
    """
    Create a default configuration file.
    
    Args:
        args: Command line arguments.
        
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    config_path = args.output or ".llm-precommit.yml"
    
    if os.path.exists(config_path) and not args.force:
        print(f"Error: Config file already exists at {config_path}")
        print("Use --force to overwrite.")
        return 1
    
    success = create_default_config_file(config_path)
    return 0 if success else 1


def run_review(args) -> int:
    """
    Run the code review on the current staged files.
    
    Args:
        args: Command line arguments.
        
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    # Convert args to sys.argv expected by the hook script
    sys.argv = ["llm-precommit"]
    if args.config:
        sys.argv.extend(["--config", args.config])
    if args.all:
        sys.argv.append("--all")
    if args.verbose:
        sys.argv.append("--verbose")
    
    return run_code_review()


def parse_args(args: Optional[List[str]] = None) -> argparse.Namespace:
    """
    Parse command line arguments.
    
    Args:
        args: List of command line arguments, or None to use sys.argv.
        
    Returns:
        Parsed arguments.
    """
    parser = argparse.ArgumentParser(
        description="LLM-powered pre-commit hooks for code review"
    )
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Install command
    install_parser = subparsers.add_parser("install", help="Install pre-commit hook")
    
    # Uninstall command
    uninstall_parser = subparsers.add_parser("uninstall", help="Uninstall pre-commit hook")
    
    # Config command
    config_parser = subparsers.add_parser("config", help="Create default configuration file")
    config_parser.add_argument("--output", "-o", help="Output path for config file")
    config_parser.add_argument("--force", "-f", action="store_true", help="Overwrite existing config file")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Run the code review manually")
    run_parser.add_argument("--config", help="Path to config file")
    run_parser.add_argument("--all", action="store_true", help="Check all files in repo, not just staged files")
    run_parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    
    return parser.parse_args(args)


def main() -> int:
    """
    Main entry point for the CLI.
    
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    args = parse_args()
    
    if args.command == "install":
        return install_hook(args)
    elif args.command == "uninstall":
        return uninstall_hook(args)
    elif args.command == "config":
        return create_config(args)
    elif args.command == "run":
        return run_review(args)
    else:
        print("Please specify a command: install, uninstall, config, or run")
        return 1


if __name__ == "__main__":
    sys.exit(main()) 